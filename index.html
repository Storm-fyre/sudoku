<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Solver - Steps 1 & 2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opencv.js/4.8.0/opencv.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .step {
            margin-bottom: 40px;
            padding: 20px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        
        .step h2 {
            color: #333;
            margin-top: 0;
        }
        
        .step.active {
            border-color: #4CAF50;
            background: #f9fff9;
        }
        
        .step.completed {
            border-color: #2196F3;
            background: #f5f9ff;
        }
        
        #imageInput {
            margin: 10px 0;
            padding: 10px;
            border: 2px dashed #ccc;
            border-radius: 5px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .image-preview {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .image-container {
            text-align: center;
        }
        
        .image-container img {
            max-width: 300px;
            max-height: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .image-container h4 {
            margin: 10px 0 5px 0;
            color: #666;
        }
        
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 40px);
            grid-template-rows: repeat(9, 40px);
            gap: 1px;
            background: #333;
            padding: 2px;
            border-radius: 5px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .sudoku-cell {
            background: white;
            border: none;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
        }
        
        .sudoku-cell:focus {
            outline: 2px solid #4CAF50;
            background: #f0f8ff;
        }
        
        .confidence-high { background: #e8f5e8; }
        .confidence-medium { background: #fff8e1; }
        .confidence-low { background: #ffebee; }
        .user-edited { background: #e3f2fd; }
        
        .thick-border-right { border-right: 3px solid #333 !important; }
        .thick-border-bottom { border-bottom: 3px solid #333 !important; }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .secondary-btn {
            background: #2196F3;
        }
        
        .secondary-btn:hover {
            background: #1976D2;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s ease;
        }
        
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .status.info { background: #e3f2fd; color: #1976D2; }
        .status.success { background: #e8f5e8; color: #388e3c; }
        .status.warning { background: #fff8e1; color: #f57c00; }
        .status.error { background: #ffebee; color: #d32f2f; }
        
        .cell-preview {
            position: absolute;
            background: white;
            border: 2px solid #333;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: none;
        }
        
        .cell-preview img {
            width: 60px;
            height: 60px;
            border: 1px solid #ddd;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            align-items: center;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sudoku Solver - Image to Editable Grid</h1>
        
        <!-- Step 1: Image Processing -->
        <div class="step active" id="step1">
            <h2>Step 1: Upload and Process Image</h2>
            <input type="file" id="imageInput" accept="image/*">
            <button id="processBtn" disabled>Process Image</button>
            
            <div class="progress" id="progressContainer" style="display: none;">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="status" id="statusMessage" style="display: none;"></div>
            
            <div class="image-preview" id="imagePreview"></div>
        </div>
        
        <!-- Step 2: Grid Review and Edit -->
        <div class="step" id="step2">
            <h2>Step 2: Review and Edit Detected Numbers</h2>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color confidence-high"></div>
                    <span>High Confidence</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color confidence-medium"></div>
                    <span>Medium Confidence</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color confidence-low"></div>
                    <span>Low Confidence</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color user-edited"></div>
                    <span>User Edited</span>
                </div>
            </div>
            
            <div class="sudoku-grid" id="sudokuGrid"></div>
            
            <button id="clearGridBtn" class="secondary-btn">Clear All</button>
            <button id="reprocessBtn" class="secondary-btn">Reprocess Image</button>
            <button id="solveBtn" disabled>Proceed to Solve</button>
            
            <div class="status" id="gridStatus" style="display: none;"></div>
        </div>
        
        <div class="cell-preview" id="cellPreview">
            <img id="previewImage" alt="Cell preview">
        </div>
    </div>

    <script>
        class SudokuProcessor {
            constructor() {
                this.originalImage = null;
                this.processedImage = null;
                this.detectedGrid = Array(9).fill().map(() => Array(9).fill(null));
                this.cellImages = Array(9).fill().map(() => Array(9).fill(null));
                this.userEdited = Array(9).fill().map(() => Array(9).fill(false));
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                document.getElementById('imageInput').addEventListener('change', this.handleImageUpload.bind(this));
                document.getElementById('processBtn').addEventListener('click', this.processImage.bind(this));
                document.getElementById('clearGridBtn').addEventListener('click', this.clearGrid.bind(this));
                document.getElementById('reprocessBtn').addEventListener('click', this.reprocessImage.bind(this));
                document.getElementById('solveBtn').addEventListener('click', this.proceedToSolve.bind(this));
            }
            
            handleImageUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.originalImage = e.target.result;
                        this.displayImage(this.originalImage, 'Original Image');
                        document.getElementById('processBtn').disabled = false;
                        this.showStatus('Image loaded successfully. Click "Process Image" to continue.', 'info');
                    };
                    reader.readAsDataURL(file);
                }
            }
            
            displayImage(imageSrc, title) {
                const preview = document.getElementById('imagePreview');
                const container = document.createElement('div');
                container.className = 'image-container';
                
                const titleEl = document.createElement('h4');
                titleEl.textContent = title;
                
                const img = document.createElement('img');
                img.src = imageSrc;
                
                container.appendChild(titleEl);
                container.appendChild(img);
                preview.appendChild(container);
            }
            
            async processImage() {
                this.showProgress(0);
                this.showStatus('Starting image processing...', 'info');
                
                try {
                    // Step 1: Load image
                    this.showProgress(10);
                    const img = await this.loadImage(this.originalImage);
                    
                    // Step 2: Perspective correction and preprocessing
                    this.showProgress(30);
                    const processedCanvas = await this.preprocessImage(img);
                    this.processedImage = processedCanvas.toDataURL();
                    this.displayImage(this.processedImage, 'Processed Image');
                    
                    // Step 3: Extract cells
                    this.showProgress(50);
                    const cells = this.extractCells(processedCanvas);
                    
                    // Step 4: OCR processing
                    this.showProgress(60);
                    await this.performOCR(cells);
                    
                    this.showProgress(100);
                    this.showStatus('Image processing completed successfully!', 'success');
                    this.activateStep2();
                    
                } catch (error) {
                    console.error('Processing error:', error);
                    this.showStatus('Error processing image: ' + error.message, 'error');
                }
            }
            
            loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = src;
                });
            }
            
            async preprocessImage(img) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Resize to standard size for processing
                const size = 450; // 50px per cell
                canvas.width = size;
                canvas.height = size;
                
                // Draw and resize image
                ctx.drawImage(img, 0, 0, size, size);
                
                // Get image data for processing
                const imageData = ctx.getImageData(0, 0, size, size);
                const data = imageData.data;
                
                // Convert to grayscale and apply contrast enhancement
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    // Apply contrast enhancement
                    const enhanced = Math.min(255, Math.max(0, (gray - 128) * 1.5 + 128));
                    data[i] = data[i + 1] = data[i + 2] = enhanced;
                }
                
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }
            
            extractCells(canvas) {
                const cells = [];
                const cellSize = 50;
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cellCanvas = document.createElement('canvas');
                        cellCanvas.width = cellSize;
                        cellCanvas.height = cellSize;
                        const cellCtx = cellCanvas.getContext('2d');
                        
                        // Extract cell region
                        cellCtx.drawImage(
                            canvas,
                            col * cellSize, row * cellSize, cellSize, cellSize,
                            0, 0, cellSize, cellSize
                        );
                        
                        // Apply additional preprocessing to cell
                        this.preprocessCell(cellCtx, cellSize);
                        
                        cells.push({
                            canvas: cellCanvas,
                            row: row,
                            col: col
                        });
                        
                        // Store cell image for preview
                        this.cellImages[row][col] = cellCanvas.toDataURL();
                    }
                }
                
                return cells;
            }
            
            preprocessCell(ctx, size) {
                const imageData = ctx.getImageData(0, 0, size, size);
                const data = imageData.data;
                
                // Calculate threshold using Otsu's method (simplified)
                let threshold = 128;
                const histogram = new Array(256).fill(0);
                
                // Build histogram
                for (let i = 0; i < data.length; i += 4) {
                    histogram[data[i]]++;
                }
                
                // Find optimal threshold (simplified Otsu)
                let total = size * size;
                let sum = 0;
                for (let i = 0; i < 256; i++) sum += i * histogram[i];
                
                let sumB = 0, wB = 0, maximum = 0;
                for (let i = 0; i < 256; i++) {
                    wB += histogram[i];
                    if (wB === 0) continue;
                    
                    let wF = total - wB;
                    if (wF === 0) break;
                    
                    sumB += i * histogram[i];
                    let mB = sumB / wB;
                    let mF = (sum - sumB) / wF;
                    let between = wB * wF * (mB - mF) * (mB - mF);
                    
                    if (between > maximum) {
                        maximum = between;
                        threshold = i;
                    }
                }
                
                // Apply threshold
                for (let i = 0; i < data.length; i += 4) {
                    const value = data[i] > threshold ? 255 : 0;
                    data[i] = data[i + 1] = data[i + 2] = value;
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            async performOCR(cells) {
                const totalCells = cells.length;
                let processedCells = 0;
                
                // Initialize Tesseract worker
                const worker = await Tesseract.createWorker();
                await worker.loadLanguage('eng');
                await worker.initialize('eng');
                await worker.setParameters({
                    tessedit_char_whitelist: '123456789',
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_CHAR,
                });
                
                for (const cell of cells) {
                    try {
                        const { data: { text, confidence } } = await worker.recognize(cell.canvas);
                        const cleanText = text.trim();
                        
                        let value = null;
                        let conf = 0;
                        
                        if (cleanText && /^[1-9]$/.test(cleanText)) {
                            value = parseInt(cleanText);
                            conf = confidence / 100;
                        }
                        
                        this.detectedGrid[cell.row][cell.col] = {
                            value: value,
                            confidence: conf
                        };
                        
                        processedCells++;
                        const progress = 60 + (processedCells / totalCells) * 35;
                        this.showProgress(progress);
                        
                    } catch (error) {
                        console.error(`OCR error for cell ${cell.row},${cell.col}:`, error);
                        this.detectedGrid[cell.row][cell.col] = {
                            value: null,
                            confidence: 0
                        };
                    }
                }
                
                await worker.terminate();
            }
            
            activateStep2() {
                document.getElementById('step1').classList.remove('active');
                document.getElementById('step1').classList.add('completed');
                document.getElementById('step2').classList.add('active');
                
                this.createSudokuGrid();
                this.validateGrid();
            }
            
            createSudokuGrid() {
                const grid = document.getElementById('sudokuGrid');
                grid.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'sudoku-cell';
                        input.maxLength = 1;
                        input.id = `cell-${row}-${col}`;
                        
                        // Add thick borders for 3x3 sections
                        if (col === 2 || col === 5) input.classList.add('thick-border-right');
                        if (row === 2 || row === 5) input.classList.add('thick-border-bottom');
                        
                        const cellData = this.detectedGrid[row][col];
                        if (cellData && cellData.value) {
                            input.value = cellData.value;
                            
                            // Set confidence-based styling
                            if (cellData.confidence > 0.8) {
                                input.classList.add('confidence-high');
                            } else if (cellData.confidence > 0.5) {
                                input.classList.add('confidence-medium');
                            } else {
                                input.classList.add('confidence-low');
                            }
                        }
                        
                        // Event listeners
                        input.addEventListener('input', (e) => this.handleCellInput(e, row, col));
                        input.addEventListener('mouseenter', (e) => this.showCellPreview(e, row, col));
                        input.addEventListener('mouseleave', () => this.hideCellPreview());
                        
                        grid.appendChild(input);
                    }
                }
            }
            
            handleCellInput(event, row, col) {
                const value = event.target.value;
                if (value && !/^[1-9]$/.test(value)) {
                    event.target.value = '';
                    return;
                }
                
                // Mark as user edited
                this.userEdited[row][col] = true;
                event.target.classList.remove('confidence-high', 'confidence-medium', 'confidence-low');
                event.target.classList.add('user-edited');
                
                this.validateGrid();
            }
            
            showCellPreview(event, row, col) {
                if (this.cellImages[row][col]) {
                    const preview = document.getElementById('cellPreview');
                    const img = document.getElementById('previewImage');
                    
                    img.src = this.cellImages[row][col];
                    
                    const rect = event.target.getBoundingClientRect();
                    preview.style.left = (rect.right + 10) + 'px';
                    preview.style.top = rect.top + 'px';
                    preview.style.display = 'block';
                }
            }
            
            hideCellPreview() {
                document.getElementById('cellPreview').style.display = 'none';
            }
            
            validateGrid() {
                const conflicts = this.findConflicts();
                let hasValues = false;
                
                // Clear previous error styling
                document.querySelectorAll('.sudoku-cell').forEach(cell => {
                    cell.style.borderColor = '';
                    if (cell.value) hasValues = true;
                });
                
                // Highlight conflicts
                conflicts.forEach(({row, col}) => {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    cell.style.borderColor = 'red';
                });
                
                // Update status
                const status = document.getElementById('gridStatus');
                if (conflicts.length > 0) {
                    status.textContent = `Found ${conflicts.length} conflicts. Please fix them before proceeding.`;
                    status.className = 'status error';
                    status.style.display = 'block';
                    document.getElementById('solveBtn').disabled = true;
                } else if (hasValues) {
                    status.textContent = 'Grid looks good! Ready to solve.';
                    status.className = 'status success';
                    status.style.display = 'block';
                    document.getElementById('solveBtn').disabled = false;
                } else {
                    status.textContent = 'Grid is empty. Please add some numbers.';
                    status.className = 'status warning';
                    status.style.display = 'block';
                    document.getElementById('solveBtn').disabled = true;
                }
            }
            
            findConflicts() {
                const conflicts = [];
                const grid = this.getCurrentGrid();
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const value = grid[row][col];
                        if (!value) continue;
                        
                        // Check row conflicts
                        for (let c = 0; c < 9; c++) {
                            if (c !== col && grid[row][c] === value) {
                                conflicts.push({row, col});
                                break;
                            }
                        }
                        
                        // Check column conflicts
                        for (let r = 0; r < 9; r++) {
                            if (r !== row && grid[r][col] === value) {
                                conflicts.push({row, col});
                                break;
                            }
                        }
                        
                        // Check 3x3 box conflicts
                        const boxRow = Math.floor(row / 3) * 3;
                        const boxCol = Math.floor(col / 3) * 3;
                        
                        for (let r = boxRow; r < boxRow + 3; r++) {
                            for (let c = boxCol; c < boxCol + 3; c++) {
                                if ((r !== row || c !== col) && grid[r][c] === value) {
                                    conflicts.push({row, col});
                                    break;
                                }
                            }
                        }
                    }
                }
                
                return conflicts;
            }
            
            getCurrentGrid() {
                const grid = Array(9).fill().map(() => Array(9).fill(null));
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.getElementById(`cell-${row}-${col}`);
                        const value = cell.value.trim();
                        grid[row][col] = value ? parseInt(value) : null;
                    }
                }
                
                return grid;
            }
            
            clearGrid() {
                document.querySelectorAll('.sudoku-cell').forEach(cell => {
                    cell.value = '';
                    cell.className = 'sudoku-cell';
                });
                
                this.userEdited = Array(9).fill().map(() => Array(9).fill(false));
                this.validateGrid();
            }
            
            reprocessImage() {
                // Reset to step 1
                document.getElementById('step2').classList.remove('active');
                document.getElementById('step1').classList.remove('completed');
                document.getElementById('step1').classList.add('active');
                
                // Clear previous results
                document.getElementById('imagePreview').innerHTML = '';
                this.hideProgress();
                this.hideStatus();
            }
            
            proceedToSolve() {
                const finalGrid = this.getCurrentGrid();
                
                // This would be passed to step 3
                console.log('Final grid for solving:', finalGrid);
                
                alert('Grid validated! This would now proceed to the solving algorithm (Step 3).\n\nCheck console for the final grid data.');
            }
            
            showProgress(percent) {
                const container = document.getElementById('progressContainer');
                const bar = document.getElementById('progressBar');
                
                container.style.display = 'block';
                bar.style.width = percent + '%';
            }
            
            hideProgress() {
                document.getElementById('progressContainer').style.display = 'none';
            }
            
            showStatus(message, type) {
                const status = document.getElementById('statusMessage');
                status.textContent = message;
                status.className = `status ${type}`;
                status.style.display = 'block';
            }
            
            hideStatus() {
                document.getElementById('statusMessage').style.display = 'none';
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new SudokuProcessor();
        });
    </script>
</body>
</html>