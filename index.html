<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Number Extractor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        
        .upload-area:hover {
            border-color: #007bff;
        }
        
        .upload-area.dragover {
            border-color: #007bff;
            background: #f0f8ff;
        }
        
        #imagePreview {
            max-width: 100%;
            max-height: 400px;
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }
        
        .progress-bar {
            height: 100%;
            background: #007bff;
            width: 0%;
            transition: width 0.3s;
        }
        
        .grid-display {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            max-width: 450px;
            margin: 20px auto;
            background: #333;
            padding: 10px;
            border-radius: 5px;
        }
        
        .cell {
            background: white;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            border: 1px solid #ccc;
        }
        
        .cell.filled {
            background: #e8f5e8;
            color: #2d5a2d;
        }
        
        .cell.empty {
            background: #f8f8f8;
            color: #999;
        }
        
        .results {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            font-family: monospace;
        }
        
        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .success {
            color: #155724;
            background: #d4edda;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .debug-canvas {
            margin: 10px 0;
            border: 1px solid #ddd;
            max-width: 100%;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            text-align: center;
        }
        
        .stat {
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
            flex: 1;
            margin: 0 5px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sudoku Number Extractor</h1>
        <p>Upload your Sudoku image with gray circular numbers to extract the grid automatically.</p>
        
        <div class="upload-area" id="uploadArea">
            <p>Click to select image or drag and drop here</p>
            <input type="file" id="fileInput" accept="image/*" style="display: none;">
        </div>
        
        <img id="imagePreview" style="display: none;">
        
        <div class="controls">
            <button id="extractBtn" disabled>Extract Numbers</button>
            <button id="copyBtn" disabled>Copy Grid as Text</button>
            <button id="clearBtn">Clear</button>
        </div>
        
        <div class="progress" id="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div id="status"></div>
        
        <div class="stats" id="stats" style="display: none;">
            <div class="stat">
                <div class="stat-value" id="filledCount">0</div>
                <div class="stat-label">Numbers Found</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="emptyCount">81</div>
                <div class="stat-label">Empty Cells</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="confidence">0%</div>
                <div class="stat-label">Avg Confidence</div>
            </div>
        </div>
        
        <div class="grid-display" id="gridDisplay" style="display: none;"></div>
        
        <div class="results" id="results" style="display: none;"></div>
        
        <canvas id="debugCanvas" class="debug-canvas" style="display: none;"></canvas>
    </div>

    <script>
        class SudokuExtractor {
            constructor() {
                this.image = null;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.grid = Array(9).fill().map(() => Array(9).fill(0));
                this.confidenceScores = [];
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const extractBtn = document.getElementById('extractBtn');
                const copyBtn = document.getElementById('copyBtn');
                const clearBtn = document.getElementById('clearBtn');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver);
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
                extractBtn.addEventListener('click', this.extractNumbers.bind(this));
                copyBtn.addEventListener('click', this.copyGrid.bind(this));
                clearBtn.addEventListener('click', this.clear.bind(this));
            }
            
            handleDragOver(e) {
                e.preventDefault();
                e.currentTarget.classList.add('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.loadImage(files[0]);
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.loadImage(file);
                }
            }
            
            loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.image = img;
                        this.displayImage();
                        document.getElementById('extractBtn').disabled = false;
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            displayImage() {
                const preview = document.getElementById('imagePreview');
                preview.src = this.image.src;
                preview.style.display = 'block';
            }
            
            async extractNumbers() {
                if (!this.image) return;
                
                this.showProgress(true);
                this.updateStatus('Preprocessing image...', 'info');
                
                try {
                    // Setup canvas
                    this.canvas.width = this.image.width;
                    this.canvas.height = this.image.height;
                    this.ctx.drawImage(this.image, 0, 0);
                    
                    // Preprocess image for better OCR
                    this.preprocessImage();
                    
                    // Extract grid
                    const cells = this.extractGridCells();
                    
                    this.updateProgress(20);
                    this.updateStatus('Extracting numbers from cells...', 'info');
                    
                    // Process each cell with OCR
                    await this.processAllCells(cells);
                    
                    this.updateProgress(100);
                    this.updateStatus('Extraction complete!', 'success');
                    this.displayResults();
                    
                } catch (error) {
                    this.updateStatus(`Error: ${error.message}`, 'error');
                } finally {
                    this.showProgress(false);
                }
            }
            
            preprocessImage() {
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Optimized preprocessing - faster pixel operations
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Fast grayscale conversion
                    const gray = (r + g + b) / 3;
                    
                    // Simplified contrast enhancement for gray numbers
                    let enhanced;
                    if (gray > 140 && gray < 220) {
                        // Gray number - enhance contrast
                        enhanced = gray < 180 ? 80 : 120;
                    } else if (gray > 240) {
                        // Background - keep white
                        enhanced = 255;
                    } else {
                        // Other elements
                        enhanced = gray;
                    }
                    
                    data[i] = enhanced;
                    data[i + 1] = enhanced;
                    data[i + 2] = enhanced;
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                
                // Show debug canvas
                const debugCanvas = document.getElementById('debugCanvas');
                debugCanvas.width = this.canvas.width;
                debugCanvas.height = this.canvas.height;
                const debugCtx = debugCanvas.getContext('2d');
                debugCtx.drawImage(this.canvas, 0, 0);
                debugCanvas.style.display = 'block';
            }
            
            extractGridCells() {
                const cells = [];
                const cellWidth = this.canvas.width / 9;
                const cellHeight = this.canvas.height / 9;
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const x = col * cellWidth;
                        const y = row * cellHeight;
                        
                        // Add small padding to avoid grid lines
                        const padding = Math.min(cellWidth, cellHeight) * 0.1;
                        const cellCanvas = document.createElement('canvas');
                        const cellCtx = cellCanvas.getContext('2d');
                        
                        cellCanvas.width = cellWidth - (padding * 2);
                        cellCanvas.height = cellHeight - (padding * 2);
                        
                        cellCtx.drawImage(
                            this.canvas,
                            x + padding, y + padding,
                            cellWidth - (padding * 2), cellHeight - (padding * 2),
                            0, 0,
                            cellCanvas.width, cellCanvas.height
                        );
                        
                        cells.push({
                            canvas: cellCanvas,
                            row: row,
                            col: col
                        });
                    }
                }
                
                return cells;
            }
            
            async processAllCells(cells) {
                this.confidenceScores = [];
                
                // Process all cells in parallel for maximum speed
                const promises = cells.map(cell => this.processSingleCell(cell));
                
                // Update progress periodically
                const progressInterval = setInterval(() => {
                    const completed = this.confidenceScores.length;
                    const progress = 20 + (80 * completed / cells.length);
                    this.updateProgress(Math.min(progress, 100));
                }, 100);
                
                await Promise.all(promises);
                clearInterval(progressInterval);
            }
            
            async processSingleCell(cell) {
                try {
                    // Optimized Tesseract configuration for speed
                    const result = await Tesseract.recognize(cell.canvas, 'eng', {
                        logger: () => {}, // Suppress logs
                        tessedit_char_whitelist: '123456789',
                        tessedit_pageseg_mode: Tesseract.PSM.SINGLE_CHAR,
                        preserve_interword_spaces: '0',
                        // Speed optimizations
                        tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
                        classify_enable_learning: '0',
                        classify_enable_adaptive_matcher: '0',
                        textord_really_old_xheight: '1',
                        segment_penalty_dict_nonword: '0',
                        language_model_penalty_non_freq_dict_word: '0',
                        language_model_penalty_non_dict_word: '0'
                    });
                    
                    const text = result.data.text.trim();
                    const confidence = result.data.confidence;
                    
                    // Lowered threshold since 38% avg is working well
                    if (text.length === 1 && /[1-9]/.test(text) && confidence > 25) {
                        this.grid[cell.row][cell.col] = parseInt(text);
                        this.confidenceScores.push(confidence);
                    } else {
                        this.grid[cell.row][cell.col] = 0;
                        this.confidenceScores.push(0);
                    }
                    
                } catch (error) {
                    console.warn(`Error processing cell ${cell.row},${cell.col}:`, error);
                    this.grid[cell.row][cell.col] = 0;
                    this.confidenceScores.push(0);
                }
            }
            
            displayResults() {
                this.displayGrid();
                this.displayTextGrid();
                this.updateStats();
                document.getElementById('copyBtn').disabled = false;
            }
            
            displayGrid() {
                const gridDisplay = document.getElementById('gridDisplay');
                gridDisplay.innerHTML = '';
                gridDisplay.style.display = 'grid';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        const value = this.grid[row][col];
                        if (value > 0) {
                            cell.textContent = value;
                            cell.classList.add('filled');
                        } else {
                            cell.textContent = '';
                            cell.classList.add('empty');
                        }
                        
                        // Add thick borders for 3x3 boxes
                        if (row % 3 === 0 && row > 0) cell.style.borderTop = '3px solid #333';
                        if (col % 3 === 0 && col > 0) cell.style.borderLeft = '3px solid #333';
                        
                        gridDisplay.appendChild(cell);
                    }
                }
            }
            
            displayTextGrid() {
                const results = document.getElementById('results');
                let gridText = 'Extracted Sudoku Grid:\n\n';
                
                for (let row = 0; row < 9; row++) {
                    let rowText = '';
                    for (let col = 0; col < 9; col++) {
                        const value = this.grid[row][col];
                        rowText += (value > 0 ? value : '.') + ' ';
                        if (col === 2 || col === 5) rowText += '| ';
                    }
                    gridText += rowText + '\n';
                    if (row === 2 || row === 5) {
                        gridText += '------+-------+------\n';
                    }
                }
                
                gridText += '\nArray format:\n';
                gridText += JSON.stringify(this.grid, null, 2);
                
                results.textContent = gridText;
                results.style.display = 'block';
            }
            
            updateStats() {
                const filledCells = this.grid.flat().filter(cell => cell > 0).length;
                const emptyCells = 81 - filledCells;
                const avgConfidence = this.confidenceScores.length > 0 
                    ? Math.round(this.confidenceScores.reduce((a, b) => a + b, 0) / this.confidenceScores.length)
                    : 0;
                
                document.getElementById('filledCount').textContent = filledCells;
                document.getElementById('emptyCount').textContent = emptyCells;
                document.getElementById('confidence').textContent = avgConfidence + '%';
                document.getElementById('stats').style.display = 'flex';
            }
            
            copyGrid() {
                const gridText = JSON.stringify(this.grid);
                navigator.clipboard.writeText(gridText).then(() => {
                    this.updateStatus('Grid copied to clipboard!', 'success');
                });
            }
            
            clear() {
                this.image = null;
                this.grid = Array(9).fill().map(() => Array(9).fill(0));
                this.confidenceScores = [];
                
                document.getElementById('imagePreview').style.display = 'none';
                document.getElementById('gridDisplay').style.display = 'none';
                document.getElementById('results').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                document.getElementById('debugCanvas').style.display = 'none';
                document.getElementById('extractBtn').disabled = true;
                document.getElementById('copyBtn').disabled = true;
                document.getElementById('fileInput').value = '';
                this.updateStatus('', '');
            }
            
            showProgress(show) {
                document.getElementById('progress').style.display = show ? 'block' : 'none';
                if (!show) this.updateProgress(0);
            }
            
            updateProgress(percent) {
                document.getElementById('progressBar').style.width = percent + '%';
            }
            
            updateStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = type;
            }
        }
        
        // Initialize the extractor when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SudokuExtractor();
        });
    </script>
</body>
</html>